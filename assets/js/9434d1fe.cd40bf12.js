"use strict";(self.webpackChunkisolate_react_docs=self.webpackChunkisolate_react_docs||[]).push([[974],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),d=l(n),u=i,h=d["".concat(p,".").concat(u)]||d[u]||c[u]||a;return n?o.createElement(h,s(s({ref:t},m),{},{components:n})):o.createElement(h,s({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=d;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var l=2;l<a;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3544:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return m},default:function(){return d}});var o=n(3117),i=n(102),a=(n(7294),n(3905)),s=["components"],r={title:"Test multiple components"},p=void 0,l={unversionedId:"isolateComponent/test-multiple-components",id:"isolateComponent/test-multiple-components",title:"Test multiple components",description:"Sometimes we want to test a component by rendering its entire component tree. You may be familiar with this technique from using enzyme's mount functionality or react-testing-library.",source:"@site/docs/isolateComponent/03-test-multiple-components.md",sourceDirName:"isolateComponent",slug:"/isolateComponent/test-multiple-components",permalink:"/isolate-react/docs/isolateComponent/test-multiple-components",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/isolateComponent/03-test-multiple-components.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Test multiple components"},sidebar:"tutorialSidebar",previous:{title:"Test a single component",permalink:"/isolate-react/docs/isolateComponent/test-a-single-component"},next:{title:"Testing useContext",permalink:"/isolate-react/docs/isolateComponent/testing-with-react-context"}},m=[],c={toc:m};function d(e){var t=e.components,n=(0,i.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Sometimes we want to test a component by rendering its entire component tree. You may be familiar with this technique from using enzyme's ",(0,a.kt)("inlineCode",{parentName:"p"},"mount")," functionality or ",(0,a.kt)("inlineCode",{parentName:"p"},"react-testing-library"),"."),(0,a.kt)("p",null,'With isolateComponent, you can choose render none, some, or all of the components in the "tree" of elements that are returned by the component you are testing.'),(0,a.kt)("p",null,"An isolated component exposes a method ",(0,a.kt)("inlineCode",{parentName:"p"},"inline()")," that will render elements that are part of the component's rendered output."),(0,a.kt)("p",null,"See the ",(0,a.kt)("a",{parentName:"p",href:"./api#inlineselector"},"inline() documentation here")),(0,a.kt)("p",null,"Let's take an example of a shopping list component that allows adding and removing items from a list:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export const ShoppingList = () => {\n  // items in the shopping list\n  const [items, setItems] = useState<Item[]>([])\n\n  // the id of the next item, used when adding an item to the list\n  const [nextId, setNextId] = useState(1)\n\n  // Render a <ShoppingListItem /> for each item in the list,\n  // And <AddItem /> at the end to allow adding an item\n  return (\n    <ul>\n      {items.map((item) => (\n        <ShoppingListItem\n          item={item}\n          key={item.id}\n          onDeleteItem={() => {\n            setItems(items.filter((i) => i.id !== item.id))\n          }}\n        />\n      ))}\n      <AddItem\n        onAddItem={(description) => {\n          const id = nextId\n          setNextId((nextId) => nextId + 1)\n          setItems([...items, { description, id }])\n        }}\n      />\n    </ul>\n  )\n}\n")),(0,a.kt)("p",null,"We can test this functionality in a couple of different ways using ",(0,a.kt)("inlineCode",{parentName:"p"},"isolateComponent"),". One way is to check the interactions between ",(0,a.kt)("inlineCode",{parentName:"p"},"ShoppingList"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ShoppingListItem"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"AddItem"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"describe('ShoppingList -- without inline', () => {\n  test('starts empty', () => {\n    const isolated = isolateComponent(<ShoppingList />)\n    expect(isolated.exists(ShoppingListItem)).toEqual(false)\n  })\n  test('add a shopping list item', () => {\n    const isolated = isolateComponent(<ShoppingList />)\n    isolated.findOne(AddItem).props.onAddItem('Avocado')\n    expect(isolated.findAll(ShoppingListItem).length).toEqual(1)\n    expect(isolated.findOne(ShoppingListItem).props.item.description).toEqual(\n      'Avocado'\n    )\n  })\n})\n")),(0,a.kt)("p",null,"These tests do ",(0,a.kt)("em",{parentName:"p"},"not")," actually render ",(0,a.kt)("inlineCode",{parentName:"p"},"ShoppingListItem")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AddItem"),". This lets us test the components individually."),(0,a.kt)("p",null,"Sometimes, though, we want to test how all these components work together. That's where ",(0,a.kt)("inlineCode",{parentName:"p"},"inline")," comes in."),(0,a.kt)("p",null,"First, let's look at the implementations of ",(0,a.kt)("inlineCode",{parentName:"p"},"ShoppingListItem")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"AddItem"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'export const ShoppingListItem = (props: {\n  item: Item\n  onDeleteItem: () => void\n}) => (\n  <li>\n    <span className="item-description">{props.item.description}</span>\n    <button className="delete-item" type="button" onClick={props.onDeleteItem}>\n      Delete\n    </button>\n  </li>\n)\n\nexport const AddItem = (props: {\n  onAddItem: (description: string) => void\n}) => {\n  const [description, setDescription] = useState(\'\')\n  return (\n    <li>\n      <label>\n        Description\n        <input\n          type="text"\n          value={description}\n          name="description"\n          onChange={(e) => setDescription(e.target.value)}\n        />\n      </label>\n      <button\n        type="button"\n        className="add-item"\n        onClick={() => {\n          props.onAddItem(description)\n          setDescription(\'\')\n        }}\n      >\n        Add Item\n      </button>\n    </li>\n  )\n}\n')),(0,a.kt)("p",null,"We can use ",(0,a.kt)("inlineCode",{parentName:"p"},"inline")," to test all of these components together:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"  test('add a shopping list item', () => {\n    const isolated = isolateComponent(<ShoppingList />)\n\n    // include child components in the rendered output\n    // can also inline *all* react components with:\n    // isolated.inline('*')\n    isolated.inline(ShoppingListItem)\n    isolated.inline(AddItem)\n\n    isolated\n      // find the input element by name\n      .findOne('input[name=description]')\n      // simulate a change event\n      .props.onChange({ target: { value: 'Avocado' } })\n\n    // find the Add button by class name\n    isolated.findOne('button.add-item').props.onClick()\n\n    // We should have two lis: shopping list item and \"add item\"\n    expect(isolated.findAll('li').length).toEqual(2)\n\n    // assert that the description matches the input\n    expect(isolated.findOne('span.item-description').content()).toEqual(\n      'Avocado'\n    )\n  })\n")),(0,a.kt)("p",null,"The choice between testing components individually or together has different tradeoffs depending on the components being tested. "),(0,a.kt)("p",null,"In general, testing components together gives confidence in the way the components integrate with each other, at the cost of  increased ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Coupling_(computer_programming)"},"coupling")," between tests and implementations."),(0,a.kt)("p",null,"Testing components"))}d.isMDXComponent=!0}}]);